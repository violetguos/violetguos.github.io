[{"authors":null,"categories":null,"content":"The task of classifying the accent of recorded speech has generally been approached with traditional SVM or UBM-GMM methods (Omar and Pelecanos, 2010; Ge, 2015). However, modern deep learning methods yield the potential to dramatically increase performance. In our report, we train several varieties of Recurrent and Convolutional Neural Networks on three types of features (MFCC, formant, and raw spectrogram) extracted from North American and British English speech recordings in order to predict the accent of the speaker. All deep learning methods examined surpass non-deep baselines, and the approach yielding the best performance was the MFCC-RNN, shortly followed by the Spec-CNN.\nThe MFCC-RNN performs best on our accent classification task, likely due to its sufficiently complex and salient features and its ability to take contextual information into account, and its performance is shortly followed by that of the the Spec-CNN (which may outperform the MFCC-RNN given more data and more computational power). The Formant-RNN performs worst of the three, likely due to the excessively low amount of information present in its features.\nA straightforward next step in evaluating these network architectures and feature choices would be to extend them beyond binary classification, including data from many varieties of English. This would allow a more direct comparison with works such as Chu, Lai, and Le (2017), which was unable to classify multiple varieties of accented English well using an MFCC approach.\nFurther future work might include expansion on the Spec-CNN, since current research continues to look into new types of convolution to curate filters for audio signals. One successful application of CNNs with raw audio involves using parametrized sinc functions in the convolution layer instead of a traditional convolution, as in SincNet developed by Ravanelli and Bengio (2018). Dilated convolutions have also been shown to be useful for accent correction and audio generation, since they allow the receptive fields to grow longer in a cheaper way than do LSTMs or other RNNs (Oord et al., 2016).\nThough it underperformed in this work, the above-baseline performance of the Formant-RNN also holds potential due to the easy interpretability of its features. Future work might construct a mapping from the features picked out as important by the network back to their original timestamp, which could be the basis of an accent correction system that delivers feedback to a user about which portions of their speech need adjustment in order to imitate a certain accent. This is especially applicable to the Formant-RNN since there is a well-understood relationship between the configuration of the mouth and the first two formants of a vowel. Such a system could provide practical instructions to the user (i.e. to raise or lower the tongue, round the lips, etc.) and could have applications in language learning or speech therapy tools.\n","date":1547339900,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547339900,"objectID":"905981a4ec4335718aa1cfa35d7a0d0a","permalink":"https://violetguos.github.io/project/accentdl/","publishdate":"2019-01-12T19:38:20-05:00","relpermalink":"/project/accentdl/","section":"project","summary":"The task of classifying the accent of recorded speech has generally been approached with traditional SVM or UBM-GMM methods (Omar and Pelecanos, 2010; Ge, 2015). However, modern deep learning methods yield the potential to dramatically increase performance. In our report, we train several varieties of Recurrent and Convolutional Neural Networks on three types of features (MFCC, formant, and raw spectrogram) extracted from North American and British English speech recordings in order to predict the accent of the speaker.","tags":[],"title":"AccentDL","type":"project"},{"authors":null,"categories":null,"content":"","date":1547338935,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547338935,"objectID":"de860ecd723f346356b20a94581dff61","permalink":"https://violetguos.github.io/project/pacmanai/","publishdate":"2019-01-12T19:22:15-05:00","relpermalink":"/project/pacmanai/","section":"project","summary":"","tags":["AI"],"title":"Pacman with AI","type":"project"},{"authors":[],"categories":[],"content":"The task of classifying the accent of recorded speech has generally been approached with traditional SVM or UBM-GMM methods (Omar and Pelecanos, 2010; Ge, 2015). However, modern deep learning methods yield the potential to dramatically increase performance. In our report, we train several varieties of Recurrent and Convolutional Neural Networks on three types of features (MFCC, formant, and raw spectrogram) extracted from North American and British English speech recordings in order to predict the accent of the speaker. All deep learning methods examined surpass non-deep baselines, and the approach yielding the best performance was the MFCC-RNN, shortly followed by the Spec-CNN.\nThe MFCC-RNN performs best on our accent classification task, likely due to its sufficiently complex and salient features and its ability to take contextual information into account, and its performance is shortly followed by that of the the Spec-CNN (which may outperform the MFCC-RNN given more data and more computational power). The Formant-RNN performs worst of the three, likely due to the excessively low amount of information present in its features.\nA straightforward next step in evaluating these network architectures and feature choices would be to extend them beyond binary classification, including data from many varieties of English. This would allow a more direct comparison with works such as Chu, Lai, and Le (2017), which was unable to classify multiple varieties of accented English well using an MFCC approach.\nFurther future work might include expansion on the Spec-CNN, since current research continues to look into new types of convolution to curate filters for audio signals. One successful application of CNNs with raw audio involves using parametrized sinc functions in the convolution layer instead of a traditional convolution, as in SincNet developed by Ravanelli and Bengio (2018). Dilated convolutions have also been shown to be useful for accent correction and audio generation, since they allow the receptive fields to grow longer in a cheaper way than do LSTMs or other RNNs (Oord et al., 2016).\nThough it underperformed in this work, the above-baseline performance of the Formant-RNN also holds potential due to the easy interpretability of its features. Future work might construct a mapping from the features picked out as important by the network back to their original timestamp, which could be the basis of an accent correction system that delivers feedback to a user about which portions of their speech need adjustment in order to imitate a certain accent. This is especially applicable to the Formant-RNN since there is a well-understood relationship between the configuration of the mouth and the first two formants of a vowel. Such a system could provide practical instructions to the user (i.e. to raise or lower the tongue, round the lips, etc.) and could have applications in language learning or speech therapy tools.\n","date":1547330641,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547330641,"objectID":"03738e51dc2c3d2b7468a8787dacb65c","permalink":"https://violetguos.github.io/post/accentdl/","publishdate":"2019-01-12T17:04:01-05:00","relpermalink":"/post/accentdl/","section":"post","summary":"The task of classifying the accent of recorded speech has generally been approached with traditional SVM or UBM-GMM methods (Omar and Pelecanos, 2010; Ge, 2015). However, modern deep learning methods yield the potential to dramatically increase performance. In our report, we train several varieties of Recurrent and Convolutional Neural Networks on three types of features (MFCC, formant, and raw spectrogram) extracted from North American and British English speech recordings in order to predict the accent of the speaker.","tags":[],"title":"Speaker Accent Classification with Deep Learning","type":"post"},{"authors":null,"categories":null,"content":"","date":1547330409,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547330409,"objectID":"83ae47f64ae81e25599a0e7e08cfa23c","permalink":"https://violetguos.github.io/project/roulette/","publishdate":"2019-01-12T17:00:09-05:00","relpermalink":"/project/roulette/","section":"project","summary":"","tags":[],"title":"Roulette","type":"project"},{"authors":null,"categories":null,"content":"","date":1547330402,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547330402,"objectID":"fc73942b80b7146c9a9e50d019816808","permalink":"https://violetguos.github.io/project/cpu/","publishdate":"2019-01-12T17:00:02-05:00","relpermalink":"/project/cpu/","section":"project","summary":"","tags":[],"title":"Cpu","type":"project"},{"authors":null,"categories":null,"content":"","date":1547326072,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547326072,"objectID":"998e98d728281dc7dbc211eca3dc4d91","permalink":"https://violetguos.github.io/project/security/","publishdate":"2019-01-12T15:47:52-05:00","relpermalink":"/project/security/","section":"project","summary":"","tags":["os","C","assembly","security"],"title":"Security Project Github Repo","type":"project"},{"authors":[],"categories":["os","C","assembly","security","systems"],"content":" Introduction Cybersecurity is a branch of study in computer system and algorithm that aims to provide security to data and programs. The two types of work done are 1. Improve computer system to shield users from attackers 2. Encrypt data so that when the device is compromised, the attacker cannot decrypt user data\nThe course project is also designed to address these two objective 1. Given a vulnerable system, implement code to attack the system 2. Program effective encryption I will provide a detailed explanation for both techniques\nWhat is code injection? Think about how many times a webpage has asked for your input: username, password, your comment on your friend\u0026rsquo;s profile picture. Your input will go into the webpage\u0026rsquo;s server. When your friend\u0026rsquo;s friend read your comment, it will be retrieved from the server, and loaded on their devices. What if your comment is not written in human language? What if it is\n\u0026quot;\\xeb\\x2a\\x5e\\x89\\x76\\x08\\xc6\\x46\\x07\\x00\\xc7\\x46\\x0c\\x00\\x00\\x00\u0026quot; \u0026quot;\\x00\\xb8\\x0b\\x00\\x00\\x00\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\u0026quot; \u0026quot;\\xb8\\x01\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x00\\xcd\\x80\\xe8\\xd1\\xff\\xff\u0026quot; \u0026quot;\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x89\\xec\\x5d\\xc3\u0026quot;  Don\u0026rsquo;t worry, as you are reading this post, your device is not compromised by this code. It has to be loaded into operating system kernel memory address in order to be exploited.\nHowever, if it is loaded into operating system [https//en.wikipedia.org/wiki/Kernel_(operating_system)]kernel memory address, this assembly code (Ron\u0026rsquo;s Code, the author Ron is the R in CLRS algorithm book) can get administrator access to everything on your OS!\nWhat is cryptography? Cryptography allows users to apply a non-linear transformation on their data. User can encrypt their data with an 128-bit key. Unlike conventional passwords, which is generated by users, is short, and is simple to crack. Many passwords contain birthday, user\u0026rsquo;s initials, important dates and places, etc. The key is random.\nIf you are interested in math, skip this note.\nNote: random here is strictly defined as pseudo-random within a space of infinite dimension. In this case, the dimension is defined by how many bits the encryption key has.\nBecause cryptography is non-linear and is based on discrete log operations, it take 2^128 trials to crack a key, which is equivalent to 5.4 *10^18 years. For more math about cryptography, please refer to http://www-inst.eecs.berkeley.edu/~cs161/sp18/notes/3.4.signatures.pdf\nMy Result For objective 1: - Implemented C language memory exploit to inject code in vulnerable program - Implement HTML, Javascript, and SQL attack to program \u0026ldquo;phishing\u0026rdquo; on vulnerable webpages\nFor objective 2: - Implemented an encrypted communication network socket in OpenSSL in C - Verified encryption using a cryptographic hash (HMAC and SHA1) in C\n","date":1510521039,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1510521039,"objectID":"c7dca9b5fa628ea6e9ab6b037928fe89","permalink":"https://violetguos.github.io/post/security/","publishdate":"2017-11-12T16:10:39-05:00","relpermalink":"/post/security/","section":"post","summary":"Introduction Cybersecurity is a branch of study in computer system and algorithm that aims to provide security to data and programs. The two types of work done are 1. Improve computer system to shield users from attackers 2. Encrypt data so that when the device is compromised, the attacker cannot decrypt user data\nThe course project is also designed to address these two objective 1. Given a vulnerable system, implement code to attack the system 2.","tags":["os","C","assembly","security"],"title":"Security Project: Exploiting OS using C and Assembly","type":"post"},{"authors":[],"categories":[],"content":" Introduction The classic algorithm for game playing is to program computers to \u0026ldquo;think\u0026rdquo; like a chess master. However, computers are not good at wholistic reasoning which often involves some philosophical ideas about chess. Instead, artificial intelligence programs a computer to search for the best move out of all moves. Right away, you may think that it is exhaustive search where you look for all the combinations of possible solutions. This is where artificial intelligence comes in and improves that search with heuristics and parallel processing to selectively search for the best move.\nAlgorithms Used  Programmed path finding algorithms, game tree with alpha-beta pruning, and Hidden Markov Model in Berkeley Pacman framework Programmed an abstract constrain satisfaction problem class using forward checking in Python to solve Sudoku and n-queens Achieved a grade of 94% in this course(CSC384)  ","date":1509537776,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1509537776,"objectID":"5809902fc73a2244e37b4021d0e88e71","permalink":"https://violetguos.github.io/post/pacmanai/","publishdate":"2017-11-01T07:02:56-05:00","relpermalink":"/post/pacmanai/","section":"post","summary":"Introduction The classic algorithm for game playing is to program computers to \u0026ldquo;think\u0026rdquo; like a chess master. However, computers are not good at wholistic reasoning which often involves some philosophical ideas about chess. Instead, artificial intelligence programs a computer to search for the best move out of all moves. Right away, you may think that it is exhaustive search where you look for all the combinations of possible solutions. This is where artificial intelligence comes in and improves that search with heuristics and parallel processing to selectively search for the best move.","tags":[],"title":"Pacman with AI","type":"post"},{"authors":[],"categories":["android","hackathon"],"content":" This is a hackathon project developed outside of school.\nProblem Far too many Canadians facing long wait times for health services experience frustration and wonder if our healthcare system is broken. Literature points to a negative impact of wait time on patients\u0026rsquo; perceptions of health care quality, satisfaction and likeability, patients\u0026rsquo; subsequent behavior, and likelihood of recommendations and repeat visits.\nHow it works Patients with our app, who have booked an appointment can check-in remotely 30 min before their appointment, if they’re close enough to the medical clinic. Alternatively, a receptionist can check patients in. However, patients don’t need to wait in the clinic for hours on end if the queue time is long, but can instead go about their day. When they’re next in line to be seen, patients would be notified to go back to the clinic.\nCode Angular.js, Express, Node.js, MongoDB, Amazon EC2, Amazon SES, Java, Android\n An Android app that aims to reduce patient waiting time built at Angel Hacks. Built with a web platform for hospital staff and a mobile app for patients Developed a function to calculate distance and configured user interface  ","date":1465768648,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1465768648,"objectID":"3d4e319dce5a6f6dab418a237391fcbf","permalink":"https://violetguos.github.io/post/andriod/","publishdate":"2016-06-12T16:57:28-05:00","relpermalink":"/post/andriod/","section":"post","summary":"This is a hackathon project developed outside of school.\nProblem Far too many Canadians facing long wait times for health services experience frustration and wonder if our healthcare system is broken. Literature points to a negative impact of wait time on patients\u0026rsquo; perceptions of health care quality, satisfaction and likeability, patients\u0026rsquo; subsequent behavior, and likelihood of recommendations and repeat visits.\nHow it works Patients with our app, who have booked an appointment can check-in remotely 30 min before their appointment, if they’re close enough to the medical clinic.","tags":["android","hackathon"],"title":"Android app to reduce clinic wait time","type":"post"},{"authors":[],"categories":["verilog","mips","hardware"],"content":" Introduction In this project, I have built a multi-cycle processor\u0026rsquo;s instruction set from scratch.\nTechnical Details  Programmed a multicycle processor in Verilog on a Altera DE-1 FPGA Configured a new Assembly language instruction set with Verilog  Lessons Learned In processor or hardware design, unlike computer software, there is no room for uncertainty. For example, a software engineer may put a button in a not so convenient place for no good reason, but it does not hinder the functionality of the app, just harder to navigate. In hardware, everything must be precise. A small error (0 vs 1) results in something completely different. As you can see below, we have tested our design on paper, drawing out each and every cycle of execution. Everything was planned beforehand.\n","date":1459596515,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1459596515,"objectID":"873c4df3ed042df026be699920797f5b","permalink":"https://violetguos.github.io/post/cpu/","publishdate":"2016-04-02T06:28:35-05:00","relpermalink":"/post/cpu/","section":"post","summary":"Introduction In this project, I have built a multi-cycle processor\u0026rsquo;s instruction set from scratch.\nTechnical Details  Programmed a multicycle processor in Verilog on a Altera DE-1 FPGA Configured a new Assembly language instruction set with Verilog  Lessons Learned In processor or hardware design, unlike computer software, there is no room for uncertainty. For example, a software engineer may put a button in a not so convenient place for no good reason, but it does not hinder the functionality of the app, just harder to navigate.","tags":["verilog","mips","hardware"],"title":"Program MIPS instruction in Verilog","type":"post"},{"authors":[],"categories":["hardware","systems","assembly"],"content":" Introduction This project was built in the same course as the multi-cycle CPU! As the reader can see, low level hardware can be fun. The two projects share similar principles, but this project has additional displays, such as a computer screen, a speaker for audio output, and we made the roulette as pretty as we could. They all run on the same hardware chip(field programmable gate array, FPGA).\nTechnical Details  Built a roulette game with PS/2 keyboard, audio output, motor, lego controller, and Altera FPGA Implemented linear feedback shift register in Assembly and C to randomize motor speed and spin time Interfaced keyboard input to prompt user’s bet and display on VGA output with JTAG UART, JPIO ports  Lessons Learned User interface (the screen display, music, and the roulette) makes a difference Creativity matters: engineers should not only focus on the technical details\nNote: this is not my final version. Unfortunately the finished product and a recorded video demo were lost.\n","date":1459578557,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1459578557,"objectID":"00d2bf0945682f74876896996194063e","permalink":"https://violetguos.github.io/post/roulette/","publishdate":"2016-04-02T01:29:17-05:00","relpermalink":"/post/roulette/","section":"post","summary":"Introduction This project was built in the same course as the multi-cycle CPU! As the reader can see, low level hardware can be fun. The two projects share similar principles, but this project has additional displays, such as a computer screen, a speaker for audio output, and we made the roulette as pretty as we could. They all run on the same hardware chip(field programmable gate array, FPGA).\nTechnical Details  Built a roulette game with PS/2 keyboard, audio output, motor, lego controller, and Altera FPGA Implemented linear feedback shift register in Assembly and C to randomize motor speed and spin time Interfaced keyboard input to prompt user’s bet and display on VGA output with JTAG UART, JPIO ports  Lessons Learned User interface (the screen display, music, and the roulette) makes a difference Creativity matters: engineers should not only focus on the technical details","tags":[],"title":"Roulette on FPGA","type":"post"}]